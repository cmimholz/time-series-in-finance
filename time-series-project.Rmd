---
title: "TIME SERIES ANALYSIS"
author: "Victor Anton, Imholz Chris"
date: "19.12.2024"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---


```{r libraries, warning=FALSE, message=FALSE}

# Load libraries
library(tidyquant)
library(quantmod)
library(ggplot2)
library(dplyr)
```

## Bedeutungen der Spaltenüberschriften

Die folgenden Spaltenüberschriften erscheinen in den heruntergeladenen
Daten. `[SYMBOL]` steht für das jeweilige Börsensymbol der Aktie.

| **Spalte** | **Bedeutung** |
|-----------------------|-------------------------------------------------|
| `[SYMBOL].Open` | Eröffnungskurs der Aktie (Price at the market open) an einem bestimmten Handelstag. |
| `[SYMBOL].High` | Höchster Kurs der Aktie während des Handelstages (Highest intraday price). |
| `[SYMBOL].Low` | Niedrigster Kurs der Aktie während des Handelstages (Lowest intraday price). |
| `[SYMBOL].Close` | Schlusskurs der Aktie am Ende des Handelstages (Price at the market close). |
| `[SYMBOL].Volume` | Anzahl der gehandelten Aktien während des Handelstages (Trading volume). |
| `[SYMBOL].Adjusted` | Angepasster Schlusskurs der Aktie, der Dividenden, Splits und andere Anpassungen berücksichtigt (Adjusted close). |

This section focuses on retrieving historical stock price data for
companies listed in the Swiss Market Index (SMI) and the S&P 500 index.
It defines the relevant stock symbols, uses a custom function to
download data from Yahoo Finance, and handles errors gracefully during
the process. The downloaded data is saved as an RDS file for future use,
ensuring efficient access and avoiding redundant downloads.

```{r share_download, echo = TRUE, fig.width=10}

# Define a list of stock symbols for the Swiss Market Index (SMI). 
# These symbols represent the 20 largest publicly traded companies in Switzerland.
smi_symbols <- c(
  "ABBN.SW", "ADEN.SW", "ALC.SW", "CFR.SW", "GEBN.SW", "GIVN.SW",
  "HOLN.SW", "BAER.SW", "KNIN.SW", "LOGN.SW", "LONN.SW", "NESN.SW",
  "NOVN.SW", "PGHN.SW", "ROG.SW", "SIKA.SW", "SOON.SW", "SLHN.SW",
  "SREN.SW", "SCMN.SW", "UHR.SW", "UBSG.SW", "ZURN.SW"
)


# Retrieve the list of symbols for companies in the S&P 500 index.
# The tq_index function fetches up-to-date information on all S&P 500 components.
 sp500 <- tq_index("SP500")
 head(sp500)

# Function to download historical stock price data for a given list of symbols.
download_data <- function(symbols, start_date = "2022-01-01",end_date = Sys.Date()) {
  stock_data <- list()
  for (symbol in symbols) {
    tryCatch({
      stock_data[[symbol]] <- getSymbols(symbol, src = "yahoo", 
                                         from = start_date, 
                                         to = end_date, 
                                         auto.assign = FALSE)
      cat("Downloaded data for:", symbol, "\n")
    }, error = function(e) {
      cat("Error downloading data for:", symbol, "\n")
    })
  }
  return(stock_data)
}

# Use the download_data function to retrieve historical stock data for all SMI symbols.
smi_data <- download_data(smi_symbols)
#s_p_data <- download_data(sp500$symbol)

# Save the downloaded SMI stock data as an RDS file.
saveRDS(smi_data, file = "smi_stock_data.rds")
#saveRDS(s_p_data, file = "s_p_stock_data.rds")

```

This section introduces a function for visualizing the adjusted stock
prices of specific companies over time. The function ensures that the
required adjusted price data is available and generates a line chart
displaying price trends with clear labels and formatting.

```{r chart visual, echo = TRUE, fig.width=10}

# Define a custom function `plot_stock` to visualize the adjusted closing prices of a stock.
plot_stock <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    stock <- stock_data[[symbol]]
    # Ensure the adjusted price column is available
    column_name <- paste0(symbol, ".Adjusted")
    if (column_name %in% colnames(stock)) {
      plot(stock[, column_name], 
           main = paste("Stock Prices for", symbol), 
           xlab = "Date", 
           ylab = "Adjusted Price", 
           col = "blue", 
           type = "l")
    } else {
      cat("Adjusted price data not available for:", symbol, "\n")
    }
  } else {
    cat("No data available for:", symbol, "\n")
  }
}


# Example usage: Visualize adjusted prices for the UBS stock.
plot_stock(smi_data, "UBSG.SW")

# Example usage: Visualize adjusted prices for Apple stock in the S&P 500.
# plot_stock(s_p_data, "AAPL")
```

This section calculates the daily percentage price changes for each
stock's adjusted closing price in the Swiss Market Index (SMI). A
utility function is applied across all stocks to compute these changes
and store them in a new column. This transformation prepares the data
for identifying significant events such as large price changes, which
are essential for strategy development.

```{r chart Change , echo = TRUE, fig.width=10}
# The `calc_percent_diff` function calculates the percentage change in the adjusted closing price for a given stock.
calc_percent_diff <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    
    close_col <- paste0(symbol, ".Adjusted")
    if (close_col %in% colnames(stock_data[[symbol]])) {
      
      close_prices <- stock_data[[symbol]][, close_col]
      percent_diff <- (close_prices / lag(close_prices) - 1) * 100
      
      percent_diff_col <- paste0(symbol, ".Percent_Diff")
      
      stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
      
      stock_data[[symbol]][, percent_diff_col] <- percent_diff
      
      
      
      return(stock_data[[symbol]])
    } else {
      cat("Close column not found for:", symbol, "\n")
      return(NULL)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# The `calc_all_percent_diff` function applies the `calc_percent_diff` function to a list of stock symbols.
calc_all_percent_diff <- function(stock_data, symbols) {
  modified_stock_data <- stock_data  # Copy the original list structure
  for (symbol in symbols) {
    modified_stock_data[[symbol]] <- calc_percent_diff(stock_data, symbol)
  }
  return(modified_stock_data)
}

# Calculate percentage differences for all stocks in the SMI.
smi_percent_diff <- calc_all_percent_diff(smi_data, smi_symbols)

# Example: View the first few rows of percentage difference data for "UBSG.SW".
head(smi_percent_diff[["UBSG.SW"]])

```

### Implementation of the Strategy

The strategy is implemented in several steps to identify and act on
significant stock price movements systematically:

1.  **Identification of Events**: Significant events are identified as
    price changes of 5% or more in the adjusted closing price.
2.  **Stock Purchase**: Stocks are purchased three trading days after a
    significant event to mitigate overreaction.
3.  **Holding Period**: The stocks are held for 30 trading days,
    allowing for potential recovery.
4.  **Return Calculation**: Returns are calculated based on the buy
    price and the sell price after 30 days.

Each step is supported by specific code implementations, which are
detailed below.

1.  **Identifying Events with ≥ 5% Price Changes**\
    Significant price movements, defined as changes of 5% or more in the
    adjusted closing price, are critical for triggering trading actions.
    To identify such events, we calculate the daily percentage change
    for each stock using the adjusted closing prices. The percentage
    change is computed using the formula:

    $$
    \text{Percentage Change} = \left(\frac{\text{Current Price}}{\text{Previous Price}} - 1\right) \times 100
    $$

    This calculation is applied across all stocks in the dataset, and
    the results are stored in a new column, `[SYMBOL].Percent_Diff`. A
    threshold filter is then applied to flag events where the percentage
    change is lower or equal to -5%.

```{r event_identification, echo = TRUE, fig.width=10}
#1. Identifikation von Ereignissen mit ≥ 5 % Kursänderung.
identify_events <- function(stock_data, symbol, threshold) {
  if (!is.null(stock_data[[symbol]])) {
    percent_diff_col <- paste0(symbol, ".Percent_Diff")
    if (percent_diff_col %in% colnames(stock_data[[symbol]])) {
      stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
      stock_data[[symbol]]$Event <- stock_data[[symbol]][, percent_diff_col] < threshold
      return(stock_data[[symbol]])
    } else {
      cat("Percent diff column not found for:", symbol, "\n")
      return(NULL)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# Initialisiere eine leere Liste, um Ergebnisse zu speichern
smi_with_events <- list()

# For-Loop, um Ereignisse zu identifizieren
for (i in seq_along(smi_percent_diff)) {
  symbol <- smi_symbols[i]  # Das aktuelle Symbol
  smi_with_events[[symbol]] <- identify_events(stock_data = smi_percent_diff, 
                                               symbol = symbol, 
                                               threshold = -5.0)
}
head(smi_with_events[["UBSG.SW"]],100)

```

2.  **Buying the Stock 3 Days After the Event**\
    To mitigate market overreaction and ensure a more stable entry
    point, the strategy specifies buying the stock three trading days
    after the identified event. This delay allows the market to
    stabilize and provides an opportunity to enter at a more predictable
    price level. The corresponding buy date is calculated for each
    flagged event.

```{r buy_3_days_later, echo = TRUE, fig.width=10}
#library(dplyr)  # Lade dplyr für if_else
# Funktion zum Hinzufügen des Kaufdatums (3. Handelsdatum nach Event)
add_buy_dates <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
    
    # TODO : braucht es eventuell nicht mehr
    # Konvertiere den Index in ein Date-Objekt und speichere es als Event_Date
    stock_data[[symbol]]$Event_Date <- as.Date(row.names(stock_data[[symbol]]))
    
    # Initialisiere Buy_Date mit NA
    stock_data[[symbol]]$Buy_Date <- as.Date(NA)
    
    # Berechne das 3. Handelsdatum nach dem Event
    for (i in which(stock_data[[symbol]]$Event)) {
      current_index <- i
      future_index <- current_index + 3  # Das 3. Handelsdatum (Index-basiert)
      
      # Prüfe, ob der zukünftige Index innerhalb der DataFrame-Grenzen liegt
      if (future_index <= nrow(stock_data[[symbol]])) {
        stock_data[[symbol]]$Buy_Date[current_index] <- stock_data[[symbol]]$Event_Date[future_index]
      }
    }
    
    return(stock_data[[symbol]])
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# For-Loop, um Kaufdaten und Ereignisdatum hinzuzufügen
smi_with_buy_dates <- list()

for (i in seq_along(smi_with_events)) {
  symbol <- smi_symbols[i]  # Das aktuelle Symbol
  smi_with_buy_dates[[symbol]] <- add_buy_dates(stock_data = smi_with_events, symbol = symbol)
}

# Beispiel: UBSG.SW anzeigen
head(smi_with_buy_dates[["UBSG.SW"]][, c("Event_Date", "Buy_Date", "Event")], 1000)


```

3.  **Holding the Stock for 30 Days**\
    After the stock is purchased, it is held for a fixed period of 30
    trading days. This duration is chosen based on the hypothesis that
    prices will recover following the initial overreaction, allowing for
    potential capital appreciation during this window.

    **Calculating Returns**\
    To evaluate the strategy's performance, the return on each trade is
    calculated as:

    $$
    \text{Return} = \frac{\text{Sell Price} - \text{Buy Price}}{\text{Buy Price}}
    $$

    Where:

    -   The **Buy Price** is the adjusted closing price on the
        calculated buy date.
    -   The **Sell Price** is the adjusted closing price 30 days after
        the buy date.

These returns are stored for analysis and aggregated to assess the
overall profitability of the strategy.

```{r holding_period, echo = TRUE, fig.width=10}
# Funktion zur Berechnung der Renditen
calculate_returns <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
    adjusted_col <- paste0(symbol, ".Adjusted")  # Angepasster Schlusskurs

    if (adjusted_col %in% colnames(stock_data[[symbol]])) {
      # Rendite berechnen
      stock_data[[symbol]]$Return <- ifelse(
        !is.na(stock_data[[symbol]]$Buy_Date),  # Wenn ein Kaufdatum existiert
        {
          # Kaufpreis (Schlusskurs am Buy_Date)
          buy_price <- lag(stock_data[[symbol]][, adjusted_col], 3)
          # Verkaufspreis (Schlusskurs nach 30 Tagen)
          sell_price <- lead(stock_data[[symbol]][, adjusted_col], 30)
          # Rendite berechnen
          (sell_price - buy_price) / buy_price
        },
        NA  # Keine Rendite, wenn kein Kaufdatum vorhanden ist
      )
      return(stock_data[[symbol]])
    } else {
      cat("Adjusted price column not found for:", symbol, "\n")
      return(NULL)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# For-Loop, um Renditen für jedes Symbol zu berechnen
smi_with_returns <- list()

for (i in seq_along(smi_with_buy_dates)) {
  symbol <- smi_symbols[i]  # Das aktuelle Symbol
  smi_with_returns[[symbol]] <- calculate_returns(stock_data = smi_with_buy_dates, symbol = symbol)
}

head(smi_with_returns[["UBSG.SW"]],1000)
```

4.  **Summary of the results**

 1. We calculate metrics that quantify the performance of the strategy:

-   **Average return**: average return across all transactions.

-   **Median return:** Avoids distortion due to outliers.

-   **Positive vs. negative returns:** Proportion of positive returns.

-   **Maximum and minimum return**: Identification of extremes.

-   **Total return:** Total return when applying the strategy to the
    entire portfolio.

```{r calculate_returns, echo = TRUE, fig.width=10}

# Funktion zum Zusammenfassen der Ergebnisse und Extrahieren der Renditen
summarize_results <- function(stock_data) {
  # Alle Renditen aus der Liste extrahieren
  returns <- do.call(rbind, lapply(stock_data, function(df) {
    if (!is.null(df$Return)) {
      return(df$Return)
    } else {
      return(NULL)
    }
  }))
  
  # Entferne NA-Werte
  returns <- returns[!is.na(returns)]
  
  # Berechnung der Kennzahlen
  summary <- list(
    average_return = mean(returns),  # Durchschnittliche Rendite
    median_return = median(returns),  # Medianrendite
    positive_ratio = sum(returns > 0) / length(returns),  # Anteil positiver Renditen
    max_return = max(returns),  # Maximale Rendite
    min_return = min(returns),  # Minimale Rendite
    total_return = sum(returns)  # Gesamtrendite
  )
  
  # Renditen global speichern, falls benötigt
  assign("returns", returns, envir = .GlobalEnv)
  
  return(summary)
}

# Ergebnisse für SMI zusammenfassen und Renditen global verfügbar machen
results_summary <- summarize_results(smi_with_returns)

# Ergebnisse ausgeben
print(results_summary)
```

### 2. **Visualization of Strategy Performance**
This section focuses on visualizing the returns generated by the implemented strategy to gain insights into its performance. Two key visualizations are included:


**a) Distribution of Returns**
Objective:
The histogram shows the frequency of positive and negative returns, providing a clear overview of the return distribution. This helps identify whether the strategy generates more positive or negative returns and highlights the variability of returns.


```{r visualize_returns, echo = TRUE, fig.width=10}

ggplot(data = data.frame(Return = returns), aes(x = Return)) +
geom_histogram(binwidth = 0.01, fill = "blue", color = "white") +
labs(title = "Verteilung der Renditen", x = "Rendite", y =
"Häufigkeit") + theme_minimal()

```

**b) Returns Over Time**
Objective:
The scatterplot shows how returns evolve over time, highlighting any trends, clusters, or patterns in the strategy’s performance.


```{r visualize_returns, echo = TRUE, fig.width=10}
# Combine all data frames into a single DataFrame and retain only valid rows
all_returns <- do.call(rbind, lapply(smi_with_returns, function(df) {
  if (!is.null(df$Buy_Date) & !is.null(df$Return)) {
    # Select rows where Buy_Date and Return are not NA
    valid_rows <- df[!is.na(df$Buy_Date) & !is.na(df$Return), c("Buy_Date", "Return")]
    return(valid_rows)
  }
  return(NULL)
}))

# Ensure Buy_Date is treated as a Date object
all_returns$Buy_Date <- as.Date(all_returns$Buy_Date)

# Conditional color assignment: red for negative, green for positive, black for zero
all_returns$Color <- ifelse(all_returns$Return < 0, "red", 
                            ifelse(all_returns$Return > 0, "green", "black"))

# Scatterplot of returns over time with color-coded points
ggplot(data = all_returns, aes(x = Buy_Date, y = Return, color = Color)) +
  geom_point(alpha = 0.7) +  # Semi-transparent points for better visibility
  scale_color_identity() +   # Use the predefined colors without adding a legend
  labs(title = "Returns Over Time", x = "Buy Date", y = "Return") +
  theme_minimal()            # Apply a clean, minimal theme
```

### **Implementation and Benchmarking of the Buy-and-Hold Strategy**

This section focuses on implementing the **Buy-and-Hold strategy** as a benchmark for evaluating the trading strategy. For each stock in the SMI, the strategy calculates the return by comparing the adjusted closing price at the start date to the adjusted closing price at the end date. The returns are averaged across all stocks to provide an overall benchmark return.

It is important to note that the average return calculated here is **not weighted**, unlike the SMI index, which is capitalization-weighted. This means that all stocks are treated equally in the calculation, regardless of their market value.

The Buy-and-Hold approach assumes no active trading decisions, offering a simple and passive investment strategy. By comparing this benchmark to the cumulative return of the trading strategy, we can assess whether active trading outperforms or underperforms a passive investment approach.


```{r benchmark, echo = TRUE, fig.width=10}  

# Funktion zur Implementierung der Buy-and-Hold-Strategie
buy_and_hold_strategy <- function(stock_data, symbol, start_date, end_date) {
  if (!is.null(stock_data[[symbol]])) {
    stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
    
    adjusted_col <- paste0(symbol, ".Adjusted")  # Angepasster Schlusskurs
    
    if (adjusted_col %in% colnames(stock_data[[symbol]])) {
      # Daten filtern für den angegebenen Zeitraum
      stock_subset <- stock_data[[symbol]][as.Date(row.names(stock_data[[symbol]])) >= as.Date(start_date) &
                                             as.Date(row.names(stock_data[[symbol]])) <= as.Date(end_date), ]
      
      # Sicherstellen, dass es genügend Daten gibt
      if (nrow(stock_subset) >= 2) {
        # Kaufpreis (angepasster Schlusskurs am Startdatum)
        buy_price <- stock_subset[1, adjusted_col]
        # Verkaufspreis (angepasster Schlusskurs am Enddatum)
        sell_price <- stock_subset[nrow(stock_subset), adjusted_col]
        # Rendite berechnen
        return <- (sell_price - buy_price) / buy_price
        return(return)
      } else {
        cat("Nicht genügend Daten für:", symbol, "\n")
        return(NA)
      }
    } else {
      cat("Adjusted price column not found for:", symbol, "\n")
      return(NA)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NA)
  }
}

# Benchmarking für alle SMI-Aktien
benchmark_smi <- function(stock_data, symbols, start_date, end_date) {
  returns <- sapply(symbols, function(symbol) {
    buy_and_hold_strategy(stock_data, symbol, start_date, end_date)
  })
  # Durchschnittliche Rendite des Benchmarks
  avg_return <- mean(returns, na.rm = TRUE)
  return(list(individual_returns = returns, average_return = avg_return))
}

# Start- und Enddatum für die Buy-and-Hold-Strategie definieren
start_date <- "2022-01-01"
end_date <- "2024-12-19"

# Benchmark-Rendite für den SMI berechnen
benchmark_results <- benchmark_smi(smi_data, smi_symbols, start_date, end_date)

# Ergebnisse anzeigen
print(benchmark_results$individual_returns)  # Individuelle Renditen der Aktien
cat("Durchschnittliche Benchmark-Rendite (Buy-and-Hold):", benchmark_results$average_return, "\n")
print(mean(benchmark_results$individual_returns))

```

### **Benchmark Comparison**

This section compares the **cumulative return** of the trading strategy to the **average Buy-and-Hold benchmark**. A bar chart visualizes the performance difference, highlighting the strategy's effectiveness against a passive investment approach.


```{r benchmark, echo = TRUE, fig.width=10}  
# Cumulative return of the trading strategy
cumulative_strategy_return <- prod(1 + returns, na.rm = TRUE) - 1  # Convert to percentage
cat("Cumulative Trading Strategy Return:", cumulative_strategy_return * 100, "%\n")

# Average return of the Buy-and-Hold benchmark (already calculated)
average_benchmark_return <- benchmark_results$average_return
cat("Average Benchmark (Buy-and-Hold) Return:", average_benchmark_return * 100, "%\n")

# Comparison visualization
comparison_data <- data.frame(
  Strategy = c("Trading Strategy", "Buy-and-Hold Benchmark"),
  Return = c(cumulative_strategy_return, average_benchmark_return)
)

# Bar plot to compare the returns
ggplot(comparison_data, aes(x = Strategy, y = Return, fill = Strategy)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) +
  labs(title = "Comparison of Trading Strategy vs Buy-and-Hold Benchmark",
       x = "Strategy", y = "Return") +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal()

```

## **Performance Analysis: Trading Strategy vs Buy-and-Hold Benchmark**

The results and visualization reveal a significant underperformance of the **trading strategy** compared to the **Buy-and-Hold benchmark**. Below is a detailed interpretation:

---

### **1. Trading Strategy Performance**
- **Cumulative Trading Strategy Return**: **-99.99%**
   - This indicates that the trading strategy nearly wiped out the investment, leading to a catastrophic loss.
   - A return of **-99.99%** means that the capital has almost completely eroded to **near-zero**.

---

### **2. Buy-and-Hold Benchmark Performance**
- **Average Benchmark Return**: **+9.67%**
   - The **Buy-and-Hold strategy** generated a positive return of **9.67%** during the same period.
   - This suggests that simply holding the SMI stocks throughout the time horizon would have yielded moderate gains.

---

### **3. Key Insights**
- The **trading strategy** drastically underperformed the benchmark.
- A **-99.99% cumulative return** indicates severe issues with the strategy logic, such as:
   - **Wrong timing** of entries and exits.
   - Poor handling of significant price drops.
   - The strategy may have flagged trades that consistently resulted in losses.
- By contrast, the **Buy-and-Hold benchmark** showed resilience, suggesting that SMI stocks as a whole delivered stable returns.

---

### **4. Potential Causes of the Strategy's Failure**
To explain such severe underperformance:
1. **Event Identification**: The threshold for significant price changes (e.g., -5%) may have resulted in frequent trades on stocks experiencing sustained declines, not recoveries.
2. **Holding Period**: Holding the stocks for 30 days may not have been sufficient to capture recoveries, or prices may have continued to decline.
3. **Execution Logic**: The logic for calculating buy and sell prices (e.g., lagged or adjusted values) may need verification.
4. **Market Conditions**: A generally bearish market during the period may have compounded losses.

---

### **5. Recommendations**
To address this:
1. **Refine the Strategy**:
   - Reassess the event thresholds and entry rules.
   - Extend or shorten the holding period based on market behavior.
2. **Include Stop-Loss Logic**:
   - Introduce mechanisms to limit losses when prices drop further after a trade is executed.
3. **Validate Data**:
   - Ensure price and return calculations are accurate and free of NA values.
4. **Backtest the Strategy**:
   - Analyze the strategy over different periods or markets to check robustness.

---

### **Conclusion**
The trading strategy's catastrophic performance highlights serious flaws in its design or execution. Meanwhile, the **Buy-and-Hold benchmark** suggests that a passive investment approach outperformed the active strategy. Revisions are needed to refine the strategy's logic and improve its performance.


## GenAI Usage
