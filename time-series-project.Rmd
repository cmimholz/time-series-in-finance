---
title: "TIME SERIES ANALYSIS"
author: "Victor Anton, Imholz Chris"
date: "19.12.2024"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
---

CHECK EXAMPLES

Structure \## 1. Identification phase: Identification of the appropriate
model (descriptive analysis!)

### Descriptive analysis

Objective: Understand how the time series in question are characterized.
Results are used as a basis for adequately modelling the subject in
question and hence as a basis for inference analysis and forecasting.

− Visualization of the data using basic graphical methods − Data
preparation and transformation − Decomposition of time series −
Description of the available data using statistical analysis (central
moments of the distribution etc.) − Multivariate analysis: How do
different variables relate to each other? − Analysis of time series
characteristics using statistical test methods

## 2. Estimation phase: Model specification and estimation of model parameters

## 3. Diagnostic phase: Evaluation of the quality and validity of the model

## 4. Operational phase: Use of the estimated model for inference analysis or forecasting

```{r libraries, warning=FALSE, message=FALSE}

# Load libraries
library(tidyquant)
library(quantmod)
library(ggplot2)
library(dplyr)
```

## Bedeutungen der Spaltenüberschriften

Die folgenden Spaltenüberschriften erscheinen in den heruntergeladenen
Daten. `[SYMBOL]` steht für das jeweilige Börsensymbol der Aktie.

| **Spalte** | **Bedeutung** |
|-----------------------|-------------------------------------------------|
| `[SYMBOL].Open` | Eröffnungskurs der Aktie (Price at the market open) an einem bestimmten Handelstag. |
| `[SYMBOL].High` | Höchster Kurs der Aktie während des Handelstages (Highest intraday price). |
| `[SYMBOL].Low` | Niedrigster Kurs der Aktie während des Handelstages (Lowest intraday price). |
| `[SYMBOL].Close` | Schlusskurs der Aktie am Ende des Handelstages (Price at the market close). |
| `[SYMBOL].Volume` | Anzahl der gehandelten Aktien während des Handelstages (Trading volume). |
| `[SYMBOL].Adjusted` | Angepasster Schlusskurs der Aktie, der Dividenden, Splits und andere Anpassungen berücksichtigt (Adjusted close). |

This section focuses on retrieving historical stock price data for
companies listed in the Swiss Market Index (SMI) and the S&P 500 index.
It defines the relevant stock symbols, uses a custom function to
download data from Yahoo Finance, and handles errors gracefully during
the process. The downloaded data is saved as an RDS file for future use,
ensuring efficient access and avoiding redundant downloads.

```{r share_download, echo = TRUE, fig.width=10}

# Define a list of stock symbols for the Swiss Market Index (SMI). 
# These symbols represent the 20 largest publicly traded companies in Switzerland.
smi_symbols <- c(
  "ABBN.SW", "ADEN.SW", "ALC.SW", "CFR.SW", "GEBN.SW", "GIVN.SW",
  "HOLN.SW", "BAER.SW", "KNIN.SW", "LOGN.SW", "LONN.SW", "NESN.SW",
  "NOVN.SW", "PGHN.SW", "ROG.SW", "SIKA.SW", "SOON.SW", "SLHN.SW",
  "SREN.SW", "SCMN.SW", "UHR.SW", "UBSG.SW", "ZURN.SW"
)


# Retrieve the list of symbols for companies in the S&P 500 index.
# The tq_index function fetches up-to-date information on all S&P 500 components.
 sp500 <- tq_index("SP500")
 head(sp500)

# Function to download historical stock price data for a given list of symbols.
download_data <- function(symbols, start_date = "2022-01-01",end_date = Sys.Date()) {
  stock_data <- list()
  for (symbol in symbols) {
    tryCatch({
      stock_data[[symbol]] <- getSymbols(symbol, src = "yahoo", 
                                         from = start_date, 
                                         to = end_date, 
                                         auto.assign = FALSE)
      cat("Downloaded data for:", symbol, "\n")
    }, error = function(e) {
      cat("Error downloading data for:", symbol, "\n")
    })
  }
  return(stock_data)
}

# Use the download_data function to retrieve historical stock data for all SMI symbols.
smi_data <- download_data(smi_symbols)
#s_p_data <- download_data(sp500$symbol)

# Save the downloaded SMI stock data as an RDS file.
saveRDS(smi_data, file = "smi_stock_data.rds")
#saveRDS(s_p_data, file = "s_p_stock_data.rds")

# Example: Accessing data for a specific stock (e.g., Nestlé)
head(smi_data[["NESN.SW"]],10)
```

smi_data

This section introduces a function for visualizing the adjusted stock
prices of specific companies over time. The function ensures that the
required adjusted price data is available and generates a line chart
displaying price trends with clear labels and formatting.

```{r chart visual, echo = TRUE, fig.width=10}

# Define a custom function `plot_stock` to visualize the adjusted closing prices of a stock.
plot_stock <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    stock <- stock_data[[symbol]]
    # Ensure the adjusted price column is available
    column_name <- paste0(symbol, ".Adjusted")
    if (column_name %in% colnames(stock)) {
      plot(stock[, column_name], 
           main = paste("Stock Prices for", symbol), 
           xlab = "Date", 
           ylab = "Adjusted Price", 
           col = "blue", 
           type = "l")
    } else {
      cat("Adjusted price data not available for:", symbol, "\n")
    }
  } else {
    cat("No data available for:", symbol, "\n")
  }
}


# Example usage: Visualize adjusted prices for the UBS stock.
plot_stock(smi_data, "UBSG.SW")

# Example usage: Visualize adjusted prices for Apple stock in the S&P 500.
# plot_stock(s_p_data, "AAPL")
```

This section calculates the daily percentage price changes for each
stock's adjusted closing price in the Swiss Market Index (SMI). A
utility function is applied across all stocks to compute these changes
and store them in a new column. This transformation prepares the data
for identifying significant events such as large price changes, which
are essential for strategy development.

```{r chart Change , echo = TRUE, fig.width=10}
# The `calc_percent_diff` function calculates the percentage change in the adjusted closing price for a given stock.
calc_percent_diff <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    
    close_col <- paste0(symbol, ".Adjusted")
    if (close_col %in% colnames(stock_data[[symbol]])) {
      
      close_prices <- stock_data[[symbol]][, close_col]
      percent_diff <- (close_prices / lag(close_prices) - 1) * 100
      
      percent_diff_col <- paste0(symbol, ".Percent_Diff")
      
      stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
      
      stock_data[[symbol]][, percent_diff_col] <- percent_diff
      
      
      
      return(stock_data[[symbol]])
    } else {
      cat("Close column not found for:", symbol, "\n")
      return(NULL)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# The `calc_all_percent_diff` function applies the `calc_percent_diff` function to a list of stock symbols.
calc_all_percent_diff <- function(stock_data, symbols) {
  modified_stock_data <- stock_data  # Copy the original list structure
  for (symbol in symbols) {
    modified_stock_data[[symbol]] <- calc_percent_diff(stock_data, symbol)
  }
  return(modified_stock_data)
}

# Calculate percentage differences for all stocks in the SMI.
smi_percent_diff <- calc_all_percent_diff(smi_data, smi_symbols)

# Example: View the first few rows of percentage difference data for "UBSG.SW".
head(smi_percent_diff[["UBSG.SW"]])

```

### Implementation of the Strategy

The strategy is implemented in several steps to identify and act on
significant stock price movements systematically:

1.  **Identification of Events**: Significant events are identified as
    price changes of 5% or more in the adjusted closing price.
2.  **Stock Purchase**: Stocks are purchased three trading days after a
    significant event to mitigate overreaction.
3.  **Holding Period**: The stocks are held for 30 trading days,
    allowing for potential recovery.
4.  **Return Calculation**: Returns are calculated based on the buy
    price and the sell price after 30 days.

Each step is supported by specific code implementations, which are
detailed below.

1.  **Identifying Events with ≥ 5% Price Changes**\
    Significant price movements, defined as changes of 5% or more in the
    adjusted closing price, are critical for triggering trading actions.
    To identify such events, we calculate the daily percentage change
    for each stock using the adjusted closing prices. The percentage
    change is computed using the formula:

    $$
    \text{Percentage Change} = \left(\frac{\text{Current Price}}{\text{Previous Price}} - 1\right) \times 100
    $$

    This calculation is applied across all stocks in the dataset, and
    the results are stored in a new column, `[SYMBOL].Percent_Diff`. A
    threshold filter is then applied to flag events where the percentage
    change is lower or equal to -5%.

```{r event_identification, echo = TRUE, fig.width=10}
#1. Identifikation von Ereignissen mit ≥ 5 % Kursänderung.
identify_events <- function(stock_data, symbol, threshold) {
  if (!is.null(stock_data[[symbol]])) {
    percent_diff_col <- paste0(symbol, ".Percent_Diff")
    if (percent_diff_col %in% colnames(stock_data[[symbol]])) {
      stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
      stock_data[[symbol]]$Event <- stock_data[[symbol]][, percent_diff_col] < threshold
      return(stock_data[[symbol]])
    } else {
      cat("Percent diff column not found for:", symbol, "\n")
      return(NULL)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# Initialisiere eine leere Liste, um Ergebnisse zu speichern
smi_with_events <- list()

# For-Loop, um Ereignisse zu identifizieren
for (i in seq_along(smi_percent_diff)) {
  symbol <- smi_symbols[i]  # Das aktuelle Symbol
  smi_with_events[[symbol]] <- identify_events(stock_data = smi_percent_diff, 
                                               symbol = symbol, 
                                               threshold = -5.0)
}
head(smi_with_events[["UBSG.SW"]],10)

```

2.  **Buying the Stock 3 Days After the Event**\
    To mitigate market overreaction and ensure a more stable entry
    point, the strategy specifies buying the stock three trading days
    after the identified event. This delay allows the market to
    stabilize and provides an opportunity to enter at a more predictable
    price level. The corresponding buy date is calculated for each
    flagged event.

```{r buy_3_days_later, echo = TRUE, fig.width=10}
#library(dplyr)  # Lade dplyr für if_else
# Funktion zum Hinzufügen des Kaufdatums (3. Handelsdatum nach Event)
add_buy_dates <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
    
    # TODO : braucht es eventuell nicht mehr
    # Konvertiere den Index in ein Date-Objekt und speichere es als Event_Date
    stock_data[[symbol]]$Event_Date <- as.Date(row.names(stock_data[[symbol]]))
    
    # Initialisiere Buy_Date mit NA
    stock_data[[symbol]]$Buy_Date <- as.Date(NA)
    
    # Berechne das 3. Handelsdatum nach dem Event
    for (i in which(stock_data[[symbol]]$Event)) {
      current_index <- i
      future_index <- current_index + 3  # Das 3. Handelsdatum (Index-basiert)
      
      # Prüfe, ob der zukünftige Index innerhalb der DataFrame-Grenzen liegt
      if (future_index <= nrow(stock_data[[symbol]])) {
        stock_data[[symbol]]$Buy_Date[current_index] <- stock_data[[symbol]]$Event_Date[future_index]
      }
    }
    
    return(stock_data[[symbol]])
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# For-Loop, um Kaufdaten und Ereignisdatum hinzuzufügen
smi_with_buy_dates <- list()

for (i in seq_along(smi_with_events)) {
  symbol <- smi_symbols[i]  # Das aktuelle Symbol
  smi_with_buy_dates[[symbol]] <- add_buy_dates(stock_data = smi_with_events, symbol = symbol)
}

# Beispiel: UBSG.SW anzeigen
head(smi_with_buy_dates[["UBSG.SW"]][, c("Event_Date", "Buy_Date", "Event")], 1000)


```

3.  **Holding the Stock for 30 Days**\
    After the stock is purchased, it is held for a fixed period of 30
    trading days. This duration is chosen based on the hypothesis that
    prices will recover following the initial overreaction, allowing for
    potential capital appreciation during this window.

    **Calculating Returns**\
    To evaluate the strategy's performance, the return on each trade is
    calculated as:

    $$
    \text{Return} = \frac{\text{Sell Price} - \text{Buy Price}}{\text{Buy Price}}
    $$

    Where:

    -   The **Buy Price** is the adjusted closing price on the
        calculated buy date.
    -   The **Sell Price** is the adjusted closing price 30 days after
        the buy date.

These returns are stored for analysis and aggregated to assess the
overall profitability of the strategy.

```{r holding_period, echo = TRUE, fig.width=10}
# Funktion zur Berechnung der Renditen
calculate_returns <- function(stock_data, symbol) {
  if (!is.null(stock_data[[symbol]])) {
    stock_data[[symbol]] <- as.data.frame(stock_data[[symbol]])
    adjusted_col <- paste0(symbol, ".Adjusted")  # Angepasster Schlusskurs

    if (adjusted_col %in% colnames(stock_data[[symbol]])) {
      # Rendite berechnen
      stock_data[[symbol]]$Return <- ifelse(
        !is.na(stock_data[[symbol]]$Buy_Date),  # Wenn ein Kaufdatum existiert
        {
          # Kaufpreis (Schlusskurs am Buy_Date)
          buy_price <- lag(stock_data[[symbol]][, adjusted_col], 3)
          # Verkaufspreis (Schlusskurs nach 30 Tagen)
          sell_price <- lead(stock_data[[symbol]][, adjusted_col], 30)
          # Rendite berechnen
          (sell_price - buy_price) / buy_price
        },
        NA  # Keine Rendite, wenn kein Kaufdatum vorhanden ist
      )
      return(stock_data[[symbol]])
    } else {
      cat("Adjusted price column not found for:", symbol, "\n")
      return(NULL)
    }
  } else {
    cat("No data available for:", symbol, "\n")
    return(NULL)
  }
}

# For-Loop, um Renditen für jedes Symbol zu berechnen
smi_with_returns <- list()

for (i in seq_along(smi_with_buy_dates)) {
  symbol <- smi_symbols[i]  # Das aktuelle Symbol
  smi_with_returns[[symbol]] <- calculate_returns(stock_data = smi_with_buy_dates, symbol = symbol)
}

head(smi_with_returns[["UBSG.SW"]],1000)
```

4.  **Summary of the results**

 1. We calculate metrics that quantify the performance of the strategy:

-   **Average return**: average return across all transactions.

-   **Median return:** Avoids distortion due to outliers.

-   **Positive vs. negative returns:** Proportion of positive returns.

-   **Maximum and minimum return**: Identification of extremes.

-   **Total return:** Total return when applying the strategy to the
    entire portfolio.

```{r calculate_returns, echo = TRUE, fig.width=10}

# Funktion zum Zusammenfassen der Ergebnisse und Extrahieren der Renditen
summarize_results <- function(stock_data) {
  # Alle Renditen aus der Liste extrahieren
  returns <- do.call(rbind, lapply(stock_data, function(df) {
    if (!is.null(df$Return)) {
      return(df$Return)
    } else {
      return(NULL)
    }
  }))
  
  # Entferne NA-Werte
  returns <- returns[!is.na(returns)]
  
  # Berechnung der Kennzahlen
  summary <- list(
    average_return = mean(returns),  # Durchschnittliche Rendite
    median_return = median(returns),  # Medianrendite
    positive_ratio = sum(returns > 0) / length(returns),  # Anteil positiver Renditen
    max_return = max(returns),  # Maximale Rendite
    min_return = min(returns),  # Minimale Rendite
    total_return = sum(returns)  # Gesamtrendite
  )
  
  # Renditen global speichern, falls benötigt
  assign("returns", returns, envir = .GlobalEnv)
  
  return(summary)
}

# Ergebnisse für SMI zusammenfassen und Renditen global verfügbar machen
results_summary <- summarize_results(smi_with_returns)

# Ergebnisse ausgeben
print(results_summary)



```

### 2. **Visualisierung**

Visualisierungen helfen dabei, die Strategie intuitiv zu verstehen.

#### a) Verteilung der Renditen:

Histogramm zeigt die Häufigkeit positiver und negativer Renditen.

```{r visualize_returns, echo = TRUE, fig.width=10}

ggplot(data = data.frame(Return = returns), aes(x = Return)) +
geom_histogram(binwidth = 0.01, fill = "blue", color = "white") +
labs(title = "Verteilung der Renditen", x = "Rendite", y =
"Häufigkeit") + theme_minimal()

```

**b) Development over time:**

Scatterplot showing returns over time and possible patterns.

```{r visualize_returns, echo = TRUE, fig.width=10}  

# Liste zu einem DataFrame zusammenführen und nur gültige Zeilen übernehmen
all_returns <- do.call(rbind, lapply(smi_with_returns, function(df) {
  if (!is.null(df$Buy_Date) & !is.null(df$Return)) {
    # Wähle nur Zeilen aus, bei denen Buy_Date und Return nicht NA sind
    valid_rows <- df[!is.na(df$Buy_Date) & !is.na(df$Return), c("Buy_Date", "Return")]
    return(valid_rows)
  }
  return(NULL)
}))

# Sicherstellen, dass Buy_Date als Date-Objekt behandelt wird
all_returns$Buy_Date <- as.Date(all_returns$Buy_Date)

# Scatterplot der Renditen über die Zeit
ggplot(data = all_returns, aes(x = Buy_Date, y = Return)) +
  geom_point(alpha = 0.5, color = "blue") +
  labs(title = "Renditen über die Zeit", x = "Kaufdatum", y = "Rendite") +
  theme_minimal()

```

Punkt 3: Evaluation der Strategie
In Punkt 3 evaluieren wir die Strategie durch Performance-Metriken und Risikoanalysen. Das Ziel ist, die Qualität der Strategie zu bewerten und ihre Stabilität in unterschiedlichen Marktphasen zu verstehen.

1. Vergleich mit Benchmarks
Die durchschnittliche Rendite der Strategie wird mit einem Marktindex wie dem S&P 500 (oder einem relevanten Benchmark wie dem SMI) verglichen.

```{r benchmark, echo = TRUE, fig.width=10}  

library(tidyr)

# Logarithmische Renditen und kumulierte Renditen berechnen
smi_benchmark <- smi_benchmark %>%
  mutate(
    Return = log(adjusted / lag(adjusted)),  # Logarithmische Renditen
    Return = replace_na(Return, 0),  # Ersetze NA-Werte durch 0 für die erste Zeile
    Cum_Return = cumprod(1 + Return)  # Kumulierte Rendite
  )

print(smi_benchmark, n= 1000)




```

```{r benchmark, echo = TRUE, fig.width=10}  

# Maximale Länge der beiden Reihen bestimmen
max_length <- max(length(returns), nrow(smi_benchmark))

# Strategie-Renditen mit NA auffüllen
strategy_combined <- c(returns, rep(NA, max_length - length(returns)))

# SMI-Renditen mit NA auffüllen
smi_combined <- c(smi_benchmark$Cum_Return, rep(NA, max_length - nrow(smi_benchmark)))

# Datum kombinieren
dates_combined <- c(as.Date(smi_benchmark$date), rep(NA, max_length - nrow(smi_benchmark)))

# Datenrahmen für den Vergleich erstellen
benchmark_data <- data.frame(
  Date = dates_combined,
  SMI = smi_combined,
  Strategy = strategy_combined
)

# Überprüfung des kombinierten Datensatzes
head(benchmark_data)


```

## GenAI Usage
